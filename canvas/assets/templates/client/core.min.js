/*
	The canvas core.

	Author: Robin Saxifrage
	License: Apache 2.0
*/
'use strict';
/*
	The canvas front-end core. Requires toolkit.js.
*/

//	Create the canvas toolkit instance.
var tk = createToolkit({
	debug: '{{ config.debug }}' == 'True'
});
//	Customize directives.
tk.snap.directive('show', function(params, right, element, resolve){
	element.classify('hidden', !resolve(params[0]));
});
tk.snap.directive('hide', function(params, right, element, resolve){
	element.classify('hidden', resolve(params[0]));
});

function CanvasCore(){
	/*
		The canvas core interface, assigned to `core` at window scope.
	*/
	var self = this;
	//	Insert configured style properties for reference.
	this.palettes = JSON.parse('{{ config.styling.palettes|json(camelize_keys=True) }}');
	this.breakpoints = JSON.parse('{{ config.styling.breakpoints|json }}');

	//	The current route and query string.
	this.route = null;
	this.query = {};
	//	The meta page and page elements.
	this.metaPage = null;
	this.page = null;

	//	Alias some toolkit properties.
	this.init = tk.init;
	this.debug = tk.config.debug;

	//	Storage.
	this.storage = {
		validators: {
			regex: function(repr, val){
				repr = repr.split(':');
				var obj = new RegExp(decodeURIComponent(repr[0]), repr[1] == '1' ? 'i' : ''),
					neg = repr[2] == '1';
				return neg != obj.test(val);
			},
			range: function(repr, val){
				if (val == '' || val == null || val == undefined){
					return false;
				}
				repr = repr.split(',')
				var min = null, max = null;
				if (repr[0] != 'null'){
					min = parseFloat(repr[0]);
				}
				if (repr[1] != 'null'){
					max = parseFloat(repr[1]);
				}
				return (min == null || val >= min) && (max == null || val <= max);
			},
			option: function(repr, val){
				if (repr == 'any'){
					return val != '' && val != null && val != undefined;
				}
			}
		},
		actions: {
			redirect: function(response){
				window.location.href = response.data.url;
			},
			refresh: function(response){
				//	Refresh page, preventing caching.
				var refresh = 1;
				var currentRefresh = self.query['refresh'];
				if (currentRefresh != null){
					refresh = (+currentRefresh) + 1;
				}
				window.location.href = window.location.pathname + '?refresh=' + refresh;
			},
			message: function(response){
				self.flashMessage = response.data.message;
			}
		},
		events: {
			stopPropagation: function(e, evt){
				evt.stopPropagation();
			},
			flashMessage: function(e){
				self.flashMessage = e.attr('cv-message');
			},
			submit: function(e){
				var form = e.parents('form');
				if (form.empty){
					throw 'No form here';
				}
				core.form(form.attr('id')).submit();
			}
		},
		form: null,
		forms: {}
	};
	

	/* -- Plugin interface -- */
	//	Plugin tracking.
	this.plugins = {};
	var unloadedPlugins = [];

	//	Function decorator template.
	function stored(map, func, name){
		if (name === undefined){
			var declaration = tk.functionName(func);
			if (declaration != '<anonymous function>'){
				name = declaration[1];
			}
			else {
				func.__targetContainer__ = map;
			}
		}
		map[name] = func;
		return func;
	}
	this.action = function(func, name){
		/*
			A function decorator for controller invokable actions.
		*/
		return stored(this.storage.actions, func, name);
	}
	
	this.event = function(func, name){ 
		/*
			A function decorator for DOM-triggered events.
		*/
		if (typeof func == 'string'){
			return this.storage.events[func];
		}
		return stored(this.storage.events, func, name); 
	}

	this.validator = function(func, name){
		/*
			A function decorator for validator implementations.
		*/
		return stored(this.storage.validators, func, name); 
	}

	this.plugin = function(PluginClass){
		/*
			Register a plugin object constructor. A second positional argument 
			specifies a condition for whether or not the plugin should be 
			instatiated;
			
			* If the condition is omitted, always instantiate the plugin.
			* If the condition is a string, instantiate the plugin if the
				string is equal to the current route.
			* If the condition is a function, invoke the function to determine
				whether to instantiate the plugin.
		*/
		var condition = tk.varg(arguments, 1, true);
		unloadedPlugins.push({
			constructor: PluginClass,
			condition: condition,
			conditionType: tk.typeCheck(condition, 'string', 'function', 'boolean')
		});
	}

	this.loadPlugins = function(){
		/*
			Load all plugins queued for load. Doesn't need to be called by 
			plugin JavaScript under normal circumstances.
		*/
		tk.iter(unloadedPlugins, function(pluginInfo){
			var load = false;
			switch (pluginInfo.conditionType){
				case 0:
					load = self.route == pluginInfo.condition;
					break;
				case 1:
					load = pluginInfo.condition();
					break;
				case 2:
					load = pluginInfo.condition;
				default:
					break;
			}
			if (!load){
				return;
			}

			//	Create the instance.
			var instance = new pluginInfo.constructor();
			tk.log('Loaded plugin:', instance);
			
			//	Add initialization function.
			if (tk.prop(instance, 'init')){
				instance.init();
			}
			
			//	Catch queued decorations.
			tk.iter(instance, function(property, value){
				if (value == null){
					return;
				}
				if (tk.prop(value, '__targetContainer__')){
					value.__targetContainer__[property] = value;
				}
			});

			self.plugins[instance.name || tk.functionName(pluginInfo.constructor)] = instance;
		});

		//	Reset unloaded.
		unloadedPlugins = [];
	}

	function Form(element){
		/*
			Form abstration object.
		*/
		var self = this;
		this.element = element;
		this.keys = [];
		this.content = {};
		this.defaultErrors = {};
		this.required = {};
		this.validators = {};
		this.errors = {};
		this.onSuccess = tk.fn.eatCall;
		this._processContent = tk.fn.identity;
		this.submitting = false;
	
		this.success = function(callback){
			this.onSuccess = callback;
			return this;
		}
	
		this.processContent = function(callback){
			this._processContent = callback;
			return this;
		}
		
		this.validate = function(){
			var key = tk.varg(arguments, 0, null);
			if (key != null){
				var value = tk.varg(arguments, 1, this.content[key]),
					validator = this.validators[key],
					pass = (value === null && !(this.required[key] && this.submitting)) || validator(value);
				this.errors[key] = pass ? null : this.defaultErrors[key];
				return pass;
			}
			else {
				var pass = true;
				tk.iter(self.keys, function(key){
					if (!self.validate(key)){
						pass = false;
					}
				});
				return pass;
			}
		}
	
		this.submit = function(){
			this.submitting = true;
			if (this.validate()){
				var fileInput = this.element.children('[type="file"]');
				if (fileInput.length > 0 && arguments.length == 0){
					//	TODO: Messy.
					if (fileInput.length != 1){
						throw 'Only one file upload per form supported';
					}
	
					var reader = new FileReader(), 
						toSend = tk.unbound(this.content),
						file = fileInput.ith(0, false).files[0];
					reader.onload = function(event){
						toSend[fileInput.attr('name')] = {
							data: btoa(event.target.result),
							mimetype: file.mimetype,
							filename: file.name,
							__file__: true
						};
						self.submit(toSend);
					}
					reader.readAsBinaryString(file);
					core.flashMessage = 'Uploading files...';
					return;
				}
	
				var toSend = tk.varg(arguments, 0, tk.unbound(this.content));
				
				//	Add additional.
				var sendSpec = this.element.is('[cv-send-action]') ? this.element : this.element.children('[cv-send-action]');
				if (!sendSpec.empty){
					toSend.action = sendSpec.attr('cv-send-action');
				}
	
				toSend = self._processContent(toSend);
				
				var specURL = element.attr('cv-submit-to');
				core.request('POST', specURL == null ? core.route : specURL)
					.json(toSend)
					.success(self.onSuccess)
					.failure(function(response){
						if (response.status == 'error'){
							core.flashMessage = 'An error occurred';
							return;
						}
	
						var summary = tk.prop(response.data, 'error_summary', null);
						self.element.snap('p.error-summary:class(hidden null()):text', summary);
	
						tk.iter(tk.prop(response.data, 'errors', {}), function(key, value){
							self.errors[key] = value;
						});
					})
					.send();
			}
			this.submitting = false;
		}
	
		this.clear = function(source){
			tk.iter(self.content, function(k){
				self.content[k] = null;
			});
		}
	
		this.populate = function(source){
			tk.iter(source, function(k, v){
				self.content[k] = v;
			});
		}
	
		//	Initialize.
		var contentBinding = tk.binding.on(this.content),
			errorBinding = tk.binding.on(this.errors);
		element
			.on('submit', function(e, event){
				self.submit();
				event.preventDefault();
			})
			.children('[name]').iter(function(e){
				var key = e.attr('name'),
					field = e.parents('.field').first(),
					error = e.attr('cv-error');
	
				//	Populate defaults.
				self.keys.push(key);
				self.content[key] = e.value();
				self.defaultErrors[key] = error === null ? 'Required' : decodeURIComponent(error);
				self.errors[key] = null;
				self.required[key] = e.is('[required]');
				
				if (e.is('[cv-validator]')){
					var repr = e.attr('cv-validator'),
						k = repr.indexOf(':'), 
						type = repr.substring(0, k);
					repr = repr.substring(k + 1);
					self.validators[key] = function(value){
						return core.storage.validators[type](repr, value);
					}
				}
				else {
					self.validators[key] = function(value){
						return !self.required[key] || value !== null;
					};
				}
	
				//	Begin implicit validation.
				contentBinding(key)
					.changed(function(newValue){
						if (newValue == '__null__'){
							newValue = null;
						}
						else if (newValue == null && e.is('select')){
							e.value('__null__');
						}
						else if (newValue != e.value()){
							e.value(newValue);
						}
	
						self.validate(key, newValue);
						return newValue;
					})
					.begin();
	
				//	Begin error binding.
				errorBinding(key)
					.changed(function(newValue){
						field.snap('$e:class(error notnull())>div.error-desc:html', newValue);
					})
					.begin();
				
				//	Attach update callback.
				e.on({
					keyup: function(e){
						self.content[key] = e.value();
					},
					change: function(e){
						self.content[key] = e.value();
					}
				});
			});
		tk.log('Created form (id ' + element.attr('id') + '): ', this);
	}
	
	tk.init(function(){
		tk('form').iter(function(e){
			var form = new Form(e);
			self.storage.forms[e.attr('id')] = form;
			self.storage.form = self.storage.form || form;
		});
	});
	
	//	TODO: Packaging.
	tk.inspection(function(check){
		check.reduce('input')
			.off('focus')
			.off('blur').on({
				focus: function(e){
					e.parents('.field').classify('focused');
				},
				blur: function(e){
					e.parents('.field').classify('focused', false);
				}
			});
	})
	
	this.form = function(){
		/*
			Return the first form, or the form with a given `cv-send-action`.
		*/
		if (arguments.length == 0){
			return this.storage.form;
		}
		else {
			return this.storage.forms[arguments[0]];
		}
	}
	
	this.forms = function(){
		return this.storage.forms;
	}
	

	//	Set up flash messages.
	this.flashMessage = null;
	tk.init(function(){
		tk('.flash-message').binding.snap(self, {
			flashMessage: '$e:class(hidden null()):text...(5000)$e:class(hidden true)'
		});
	});

	//	Set up tooltip creation.
	this.tooltip = function(target){
		var pos = target.offset(),
			targetSize = target.size(),
			text = tk.varg(arguments, 2, target.attr('cv-tooltip'));

		var right = pos.x > self.page.size().width/2,
			scroll = this.page.ith(0, false).scrollTop;

		//	TODO: make right do something.

		return self.page.snap('+div.tooltip:class(hidden null()):class(right $r):css(top $t):css(left $l):text', text, {
			r: right,
			t: pos.y - scroll - 10,
			l: pos.x + targetSize.width/2 - 10
		});
	}
	tk.inspection(function(check){
		check.reduce('[cv-tooltip]').iter(function(e){
			var tooltip = null;
			e.on({
				mouseover: function(){
					tooltip = self.tooltip(e);
				},
				mouseout: function(){
					tooltip.remove();
				}
			})
		});
	});

	//	Customize requests.
	this.request = function(){
		var varg = tk.varg.on(arguments);
		return tk.request(varg(0, 'POST'), varg(1, window.location.href));
	}
	tk.request.processor(function(request){
		request.header('X-Canvas-View-Request', '1');
		if (request.fns.success === tk.fn.eatCall){
			//	Add an action check response.
			request.fns.success = function(response){
				if (tk.prop(response, 'data') && tk.prop(response.data, 'action')){
					core.storage.actions[response.data.action](response);
				}
			}
		}
		if (request.fns.failure === tk.fn.eatCall){
			request.fns.failure = function(){
				self.flashMessage = 'An error occured';
			}
		}
	});
	
	this.Modal = function(){
		/*
			A modal class for extension.
		*/
		var self = this;
		this.element = null;
	
		this.create = tk.fn.notImplemented;
	
		this.open = function(){
			this.element = core.page.snap('+div.modal')
				.on('click', this.close)
				.snap('+div.panel')
					.on('click', function(e, evt){
						evt.stopPropagation();
					})
					.snap('+i.fa.fa-times.closer')
						.on('click', this.close)
					.back()
				.back();
			this.create(this.element.snap('div.panel'));
		}
	
		this.close = function(){
			self.element.remove();
		}
	}
	
	this.modal = function(modalClass){
		/*
			Create, open, and return an instance of the given Modal class.
		*/
		var inst = new modalClass();
		inst.open();
		return inst;
	}

	//	Set up event-binding inspection.
	tk.inspection(function(check){
		check.reduce('[cv-event]')
			.on('click', function(e, evt){
				var key = e.attr('cv-event'),
					event = tk.prop(self.storage.events, key, null);
				if (event != null){
					event(e, evt);
				}
				else {
					throw 'No such event: ' + key;
				}
			})
		.back()
		.reduce('.button').classify('open', function(e){
			return e.attr('href') == self.route;
		})
		.back()
		.reduce('[cv-action]')
			.on('click', function(e){
				self.request()
					.json({
						action: e.attr('cv-action')
					})
					.send();
			});
	});
	
	//	Set up core initialization.
	tk.init(function(){
		var body = tk('body');
		//	Parse DOM.
		self.route = body.attr('cv-route');
		self.page = body.children('.page', false);
		self.metaBody = body.children('.meta-body');

		//	Parse query string.
		tk.iter(window.location.search.substring(1).split('&'), function(param){
			param = param.split('=');
			self.query[decodeURIComponent(param[0])] = decodeURIComponent(param[1]);
		});

		//	Load plugins.
		//	TODO: So greasy.
		tk.timeout(self.loadPlugins, 250);
	});
}
//	Create.
var core = new CanvasCore();
