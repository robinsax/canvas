#	coding utf-8
'''
SQL serialization.
'''

from ..exceptions import (
	UnsupportedEnformentMethod,
	InvalidQuery,
	UnadaptedType
)

#	TODO: Refactor this import.
from .type_adaption import _adapted_types
from .columns import _sentinel

#	Many of these exports are intended for in-package use only.
__all__ = [
	#	Classes.
	'SQLExpression',
	'SQLComparison',
	'SQLAggregatorCall',
	#	Functions - package internal.
	'table_creation',
	'retrieval',
	'row_creation',
	'row_update',
	'row_deletion'
]

#	Define SQL expression construtors.
#	TODO: Integrate constraints with this pattern.
class SQLExpression:
	'''
	A base class used for object that represent an expression that serializes
	to an SQL prepared statement.
	
	Used primarily for query generation.
	'''

	def serialize_node(self, node, values):
		'''
		A helper function for expression node serialization.

		Invoke `serialize()` on `SQLExpression`s and serialize leaves 
		(primitive values).
		'''
		if isinstance(node, SQLExpression):
			return node.serialize(values)
		elif node is None:
			#	This node is a NULL value.
			return 'NULL'
		elif isinstance(node, bool):
			#	This node is a boolean.
			return 'TRUE' if node else 'FALSE'
		elif isinstance(node, tuple(_adapted_types)):
			#	This node is an adaptable primitive; serialize it as a format 
			#	and append it to the values list.
			values.append(node)
			return '%s'
		else:
			raise UnadaptedType(repr(node))

	def as_condition(self, values):
		'''
		Return this expression serialized as an SQL query condition.
		'''
		return f'WHERE {self.serialize(values)}'

	def serialize(self, values):
		'''
		The method to implement. Create an SQL representation of the expression.

		:values The current list of values for insertion into the generated
			prepared statement. Since the expression evaluation is in-order,
			values should be appended to the `values` list.
		'''
		raise NotImplemented()

class SQLComparison(SQLExpression):
	'''
	An SQL-serializable expression of model attribute comparison.

	Generated by columns on comparison.
	'''

	def __init__(self, left, right, operator):
		'''
		Create a column comparator representing a comparsion of `left` to `right` 
		using the SQL operator `operator`.
		'''
		#	Left and right sides of the expression.
		self.left, self.right = (left, right)
		#	The operator as a string.
		self.operator = operator
		
		#	Placeholder properties modifiable by later unary operations.
		self.inverted = False
		self.grouped = False

	def serialize(self, values):
		'''
		Serialize this comparison as SQL.
		'''
		#	Run inorder traversal.
		left_sql = self.serialize_node(self.left, values)
		right_sql = self.serialize_node(self.right, values)

		#	Handle the NULL comparsion case.
		if right_sql == 'NULL':
			if self.operator == '=':
				self.operator = 'IS'
			if self.operator == '<>':
				self.operator = 'IS NOT'

		sql = f'{left_sql} {self.operator} {right_sql}'

		#	Apply precedence and inversion modifiers.
		if self.grouped:
			sql = f'({sql})'
		if self.inverted:
			sql = f'NOT {sql}'
		return sql

	def group(self):
		'''
		Group this comparison expression to give it precedence.
		'''
		self.grouped = True
		return self
	
	def __invert__(self):
		'''
		Group and logically invert this comparison expression.
		'''
		self.grouped = True
		self.inverted = True
		return self

	def __and__(self, other):
		'''
		Return a conjunction of this expression and another.
		'''
		return SQLComparison(self, other, 'AND')

	def __or__(self, other):
		'''
		Return a disjunction of this expression and another.
		'''
		return SQLComparison(self, other, 'OR')

class SQLAggregatorCall(SQLExpression):
	'''
	An SQL aggregator function call expression.
	'''

	def __init__(self, func, column, weight=0):
		#	TODO: Refactor this import.
		from .columns import Column

		#	Assert parameter is a column.
		if not isinstance(column, Column):
			raise InvalidQuery('Aggregator parameter is not a column')

		self.func, self.column = func, column

		#	Weight is used for the `max()` and `min()` trick.
		self.weight = weight

	def as_condition(self, values):
		return f'WHERE {self.column.name} = (SELECT {self.serialize(values)} FROM {self.column.model.__table__})'

	def serialize(self, values):
		return f'{self.func}({self.serialize_node(self.column, values)})'

	def __gt__(self, other):
		return self.weight > other.weight

def _column_ordering(model_cls):
	'''
	Serialize the pre-determined column order for the given model class.
	'''
	return ', '.join(model_cls.__columns__)

def enum_creation(enum_cls):
	'''
	In-Postgres enumerable type creation. Complicated by the lack of an 
	`IF NOT EXISTS` option.
	'''
	#	Get the in-Postgres type name.
	name = enum_cls.__type_name__

	type_format = ', '.join(['%s']*len(enum_cls))
	return f'''
		DO $$ BEGIN
			IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = {name}) THEN
				CREATE TYPE {name} AS ENUM ({type_format});
			END IF;
		END$$;
	''', [e.name for e in enum_cls]

def table_creation(model_cls):
	'''
	Serialize a table creation with IF NOT EXISTS option since table creation 
	is issued every time canvas is initialized.
	'''
	#	TODO: Refactor this import.
	from .columns import ForeignKeyColumnType

	def column_definition(col):
		'''
		Serialize a column generation.
		'''
		#	Create definition base; name and type.
		col_sql = f'{col.name} {col.type.sql_type}'

		if col.primary_key:
			#	Add primary key modifier.
			col_sql = f'{col_sql} PRIMARY KEY'

		#	Add foreign key target if applicable.
		if isinstance(col.type, ForeignKeyColumnType):
			target = col.reference
			col_sql = f'{col.name} {target.type.sql_type} REFERENCES {target.model.__table__}({target.name})'
		
		#	Add all constraints that support SQL serialization.
		for constr in col.constraints:
			try:
				col_sql = f'{col_sql} CONSTRAINT {constr.name} {constr.as_sql()}'
			except UnsupportedEnformentMethod:
				#	This constraint isn't representable in SQL.
				pass
		
		return col_sql

	#	Define each column and join
	col_defns = ', '.join([
		column_definition(o) for n, o in model_cls.schema_iter()
	])
	
	#	Return formatted statement.
	return f'CREATE TABLE IF NOT EXISTS {model_cls.__table__} ({col_defns});', ()

#	TODO: Finish allowing scalar to tuple retrieval.
def retrieval(target, query, ordering=None):
	'''
	Serialize a retrieval based on some query condition.
	
	:target The retrieval target.
	:query The query condition.
	'''
	#	TODO: Refactor this import.
	from .columns import Column

	#	Serialize and prepare the query.
	values = []
	
	#	Parse query.
	if query is True:
		#	No condition.
		condition = None
	elif isinstance(query, SQLExpression):
		#	Serialize the condition.
		condition = query.as_condition(values)
	else:
		raise InvalidQuery(f'Bad query condition {repr(query)}')

	#	Parse selection.
	if hasattr(target, '__schema__'):
		#	Full-model retrieval.
		selection = _column_ordering(target)
		table = target.__table__
	elif isinstance(target, SQLExpression):
		#	Aggregation or column retrieval.
		selection = target.serialize([])

		#	Get table.
		if isinstance(target, SQLAggregatorCall):
			target = target.column
		table = target.model.__table__
	else:
		raise InvalidQuery(f'Bad query selection {repr(query)}')

	sql = f'SELECT {selection} FROM {table}'

	#	Maybe add condition.
	if condition is not None:
		sql = f'{sql} {condition}'
	
	#	Maybe order.
	if ordering is not None:
		column, ascending = ordering
		order = 'ASC' if ascending else 'DESC'
		sql = f'{sql} ORDER BY {column.serialize([])} {order}'

	#	Return.
	return f'{sql};', values

def row_update(model):
	'''
	Serialize a row update based on a loaded model object.

	:model The model instance whose row to update.
	'''
	model_cls = model.__class__

	#	Create assignment statement.
	assignments, values = [], []
	for name, column in model_cls.schema_iter():
		#	Retrieve the column value.
		value = column.value_for(model)

		if value is _sentinel:
			#	This is a call to `save()` and this column
			#	has not been populated; allow it to default.
			continue
		values.append(value)
		assignments.append(f'{name} = %s')
	
	#	Comma-seperate assignments.
	assignments = ', '.join(assignments)
	
	#	Create row access expression.
	row_access = f'{model_cls.__primary_key__.name} = %s'
	values.append(model.__orm_ref__)
	
	#	Return formatted statement.
	return f'UPDATE {model_cls.__table__} SET {assignments} WHERE {row_access};', values

def row_creation(model):
	'''
	Serialize a row insertion based on a constructed 
	model object.
	'''
	model_cls = model.__class__

	#	We can't rely on `__columns__` for order here since 
	#	sentineled values are not inserted.
	values, order = [], []
	for name, column in model_cls.schema_iter():
		if column.value_for(model) == _sentinel:
			#	Skip this column to allow defaults to
			#	take effect.
			continue
		order.append(name)
		values.append(column.value_for(model))
	
	#	Comma seperate assignments and order.
	assignments = ', '.join(['%s' for x in order])
	order = ', '.join(order)

	#	Return formatted statement.
	return f'INSERT INTO {model_cls.__table__} ({order}) VALUES ({assignments}) RETURNING {_column_ordering(model_cls)};', values

def row_deletion(model):
	'''
	Delete the corresponding row for the given
	model object
	'''
	model_cls = model.__class__

	#	Create row access expression.
	pk_col = model_cls.__primary_key__.name

	#	Return formatted statement.
	return f'DELETE FROM {model_cls.__table__} WHERE {pk_col} = %s;', (model.__orm_ref__,)
